// LightPoint.CPP
// Implementation autogenerated by MJEngine automation tools
// WARNING: Do not modify autogenerated comments, automation 
// tools depend on them.

// Edition author: mzaldivar

#include "LightPointComponent.h"
#include "GameObject.h"
#include "GLObject.h"
#include "Shader.h"
#include "TransformComponent.h"
#include "RenderManager.h"
#include "Render3D.h"
#include <sstream>

#include <glew.h>

extern RenderManager* renderManager;

LightPointComponent::LightPointComponent()
{
}


LightPointComponent::~LightPointComponent()
{
}


bool LightPointComponent::Init()
{
	if (GetOwner()->IsDeferred)
	{
		lightAmbient = glm::vec3(0.15f, 0.15f, 0.15f) * 1.5f;
		lightIntensity = glm::vec3(1.1f, 1.1f, 1.1f)*9.0f; // -> serialize this info later
		lightColor = glm::vec3(1.0f, 0.0f, 1.0f);
		return true;
	}
		
	// TODO - Implement initializations here
	// This function runs once when object manager
	// load objects, before serialization
	lightAmbient = glm::vec3(0.15f, 0.15f, 0.15f)*1.5f;
	lightIntensity = glm::vec3(1.3f, 1.3f, 1.3f)*2.0f; // -> serialize this info later
	
	
	// light hardcoded!!!
	
	
	lightColor = glm::vec3(0.5f, 0.5f, 0.5f);

	
	
	
	
	TransformComponent* trans = GetOwner()->FindComponent<TransformComponent>();
	lighPosition = trans->GetPosition();
	BRDFLight lightPoint;
	lightPoint.LightPosition = &lighPosition;
	lightPoint.LightAmbient = &lightAmbient;
	lightPoint.LightIntensity = &lightIntensity;
	lightPoint.LighColor = &lightColor;
	if (!GetOwner()->IsDeferred)
	{
		renderManager->GetRender3D()->PushLight(lightPoint);
	}
	

	return true;
}


void LightPointComponent::Update()
{
	/*if (!GetOwner()->IsAlive)
		return;*/

	// Get the position of the new sphere
	TransformComponent* trans = GetOwner()->FindComponent<TransformComponent>();
	lighPosition = trans->GetPosition();
	lighPosition.y = 10.0f;


	// send information to corresponding shader
	if (!GetOwner()->IsDeferred)
		return;



	// only if object is deferred, local light
	GLint currentProgramId;
	glGetIntegerv(GL_CURRENT_PROGRAM, &currentProgramId);

	GLuint posLoc = glGetUniformLocation(currentProgramId, "LightPosition");
	glUniform3fv(posLoc, 1, &lighPosition[0]);


	GLuint ambientLoc = glGetUniformLocation(currentProgramId, "LightAmbient");
	glUniform3fv(ambientLoc, 1, &lightAmbient[0]);


	GLuint intensityLoc = glGetUniformLocation(currentProgramId, "LightIntensity");
	glUniform3fv(intensityLoc, 1, &lightIntensity[0]);


	GLuint colorLoc = glGetUniformLocation(currentProgramId, "LightColor");
	glUniform3fv(colorLoc, 1, &lightColor[0]);

	glm::vec3 cameraPos = renderManager->GetRender3D()->CurrentCamera->Position;
	GLint cameraPosLocation = glGetUniformLocation(currentProgramId, "CameraPos");
	glUniform3fv(cameraPosLocation, 1, &cameraPos[0]);



	//TransformComponent* trans = GetOwner()->FindComponent<TransformComponent>();

	/*GLint pid = 0;
	glGetIntegerv(GL_CURRENT_PROGRAM, &pid);

	GLint loc = 0;
	loc = glGetUniformLocation(pid, "ObjectScale");
	glUniform1f(loc, trans->GetScale().x);
*/



}


void LightPointComponent::Serialize(std::istringstream* objcontentStream)
{
	std::string line;
	std::getline((*objcontentStream), line);

	std::istringstream lineStream(line.c_str());
	std::string word;

	while ((*objcontentStream) >> word)
	{
		if (word == "#")
		{
			std::getline((*objcontentStream), line);
			continue;
		}
		
		// TODO - Implement more if statements according to the file format
		// This function runs right after the Init function

	}
}


