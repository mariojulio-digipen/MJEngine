// FollowMeComponent.CPP
// Implementation autogenerated by MJEngine automation tools
// WARNING: Do not modify autogenerated comments, automation 
// tools depend on them.

// Edition author: mzaldivar

#include "FollowMeComponent.h"
#include "GameObject.h"
#include "ResourceManager.h"
#include "TransformComponent.h"
#include "RenderManager.h"
#include "Render3D.h"
#include "Event.h"
#include "EventManager.h"
#include "UIManager.h"

#include <glm.hpp>
#include <gtx\euler_angles.hpp>
#include <gtx\transform.hpp>



extern ResourceManager* resourceManager;
extern UIManager* uiManager;


void drawDebugVectors(std::vector<GameObject*>* links, int* k, glm::vec3* jk, glm::vec3* pc, glm::vec3* pd, glm::vec3* normal);

FollowMeComponent::FollowMeComponent()
{
}


FollowMeComponent::~FollowMeComponent()
{
}


bool FollowMeComponent::Init()
{
	// TODO - Implement initializations here
	// This function runs once when object manager
	// load objects, before serialization

	// the reference to the transform component of the target
	targetTrans = GetOwner()->FindComponent<TransformComponent>();

	// references to the skeleton parts
	std::vector<GameObject*> tmp;
	endEffector = resourceManager->GetGameObjectByName(end_effector);
	tmp.push_back(endEffector);
	getBonesHierarchy(endEffector, &tmp);
	size_t bonesNumber = links.size();
	for (size_t i = bonesNumber; i > 0; i--)
		priorityList.push_back(i - 1);

	return true;
}


void FollowMeComponent::Update()
{
	// TODO - Implement all the updates here
	// This function is executed once everyframe

	uiManager->CCDCloseEnough = false;
	computeCCD();

}


void FollowMeComponent::HandleEvent(const Event* const evt)
{
	// TODO - Implement reactions to different events
	const IKGrabTarget* ikGrab =
		dynamic_cast<const IKGrabTarget*>(evt);
	if (ikGrab != NULL)
	{
		startIKCCD = true;
	}

	const IKCCDResetIterations* resetCCDIters =
		dynamic_cast<const IKCCDResetIterations*>(evt);
	if (resetCCDIters)
	{
		ccd_iterations = 0;
	}
}



void FollowMeComponent::computeCCD()
{

	float delta = 0.5;
	glm::vec3 Pd = targetTrans->GetPosition();
	glm::vec3 Pc = endEffector->GetGLObject()->Transform->VQS_ModelToWorld.Translator.Vector;


	for (size_t i = 1; i < priorityList.size(); i++)
	{
		int k = priorityList[i];

		glm::vec3 jk = links[k]->FindComponent<TransformComponent>()->GetPosition();

		// map to local space
		glm::mat4 inv = glm::inverse(links[k]->GetGLObject()->Transform->ModelToWorld);
		// Pc in local space
		glm::vec4 tmpc = inv * glm::vec4(Pc, 1.0f);
		glm::vec3 Pc_local = glm::vec3(tmpc);
		// Pd in local space
		glm::vec4 tmpd = inv * glm::vec4(Pd, 1.0f);
		glm::vec3 Pd_local = glm::vec3(tmpd);
		// jk in local space
		glm::vec4 tmpjk = inv * glm::vec4(jk, 1.0f);
		glm::vec3 jk_local = glm::vec3(tmpjk);


		// debug normal
		glm::vec3 debug_Vck_local = Pc_local - jk_local;
		glm::vec3 debug_Vdk_local = Pd_local - jk_local; 
		glm::vec3 debug_n_Vck_local = glm::normalize(debug_Vck_local);
		glm::vec3 debug_n_Vdk_local = glm::normalize(debug_Vdk_local);

		// local space normal
		glm::vec3 debugNormal_local = glm::cross(debug_n_Vdk_local, debug_n_Vck_local);
		glm::vec3 n_debugNormal_local = glm::normalize(debugNormal_local);


		// debug vectors
		//drawDebugVectors(&links, &k, &jk, &Pc, &Pd, &n_debugNormal_local);




		if (!uiManager->CCDRotateContinuous)
		{
			if (!uiManager->CCDRotate)
				return;
		}

		if (!startIKCCD)
			return;

		// is it close enough? if so, finish, otherwise, continue
		bool closeEnough = evaluateDistanceCurrentLinkToTarget(&Pd, &Pc);
		if (closeEnough)
		{
			//std::cout << "Should stop" << std::endl;
			uiManager->CCDCloseEnough = true;
			return;
		}

		// compute angle between Vck and Vdk
		float debug_n_Vck_length = glm::length(debug_n_Vck_local);
		float debug_n_Vdk_length = glm::length(debug_n_Vdk_local);
		float cosine = glm::dot(debug_n_Vdk_local, debug_n_Vck_local) / (debug_n_Vck_length * debug_n_Vdk_length);
		if (cosine >= 1.0f)
			cosine = 1.0f;
		if (cosine <= -1.0f)
			cosine = -1.0f;

		if(i == priorityList.size())
			if (cosine >= 0.9999)
				cosine = 0.9999;

		// clamps and constraints
		// The application shows a snake-like skeleton, with this constraints, the "snake"
		// will struggle when trying to reach the goal because of the constraints given, 
		// for example, if normally it can go directly to the target ball, in this case instead, 
		// it will rotate reaccomodate its bones until it can stretch its body out. Sometimes,
		// the snake might get entangled and will be even harder to stretch out its body to 
		// reach the target.
		float angle = -glm::acos(cosine);

		float for_clamp = glm::degrees(angle);
		angle = glm::clamp(for_clamp, -0.2f, 0.2f);
		angle = glm::radians(angle);

		if (k != 0)
			if (cosine >= 0.958393)
				angle = 0.0f;

		glm::vec3 rotationAxis = glm::normalize(n_debugNormal_local);
		Quaternion VQS_Q = Quaternion::QuatFromAxisAngle(angle, rotationAxis);
		VQS_Q.Normalize();


		Quaternion old_rotator = links[k + 1]->GetGLObject()->Transform->VQS_RotatorForBoneIK;

		// constraints in x (for 3 first links)
		Quaternion new_rotator = VQS_Q;
		glm::vec3 euler_angles = new_rotator.GetEulerAngles();
		float x = glm::degrees(euler_angles.x);
		float y = glm::degrees(euler_angles.y);
		float z = glm::degrees(euler_angles.z);


		if ((k == 0 || k == 1 || k == 2) && (rotationAxis.y < -0.1f && rotationAxis.y > 0.1))
		{
			if (x > 45.0f || x < -45.0f)
			{
				x = glm::radians(0.0f);
				y = glm::radians(x);
				z = glm::radians(z);
				euler_angles = glm::vec3(x, y, z);

				VQS_Q = Quaternion::QuatFromAngles(euler_angles);
				VQS_Q.Normalize();
			}
		}

		links[k + 1]->GetGLObject()->Transform->VQS_RotatorForBoneIK = VQS_Q*old_rotator;

	}

	uiManager->CCDRotate = false;
	ccd_iterations++;
	return;
}


bool FollowMeComponent::evaluateDistanceCurrentLinkToTarget(glm::vec3* pd, glm::vec3* pc)
{
	float distance = glm::distance((*pc), (*pd));
	uiManager->CCDDesiredDistance = distance;
	if (distance < 0.5f) // move the move very near to the target so you can test the requirement
		return true;
	else
	{
		if (ccd_iterations >= 1000) // no more than 1000 iterations. If more, just stop searching
			return true;
		else
			return false;
	}
}

void FollowMeComponent::getBonesHierarchy(GameObject* go, std::vector<GameObject*>* links)
{
	// get the links recursively.
	GameObject* parent = go->GetParent();
	links->push_back(parent);
	if (parent->GetName() != root)
		getBonesHierarchy(parent, links);
	else
	{
		for (int i = links->size() - 1; i >= 0; i--)
			this->links.push_back((*links)[i]);
	}
}

void drawDebugVectors(std::vector<GameObject*>* links, int* k, glm::vec3* jk, glm::vec3* pc, glm::vec3* pd, glm::vec3* normal)
{
	// start debug vectors
	// debug green lines (drawn as global space, for debug)
	(*links)[(*k) + 1]->GetGLObject()->DrawLine((*jk),
		(*pc), glm::vec3(0.0f, 1.0f, 0.0f), 4.0f);
	(*links)[(*k)]->GetGLObject()->DrawLine((*pd),
		(*jk), glm::vec3(0.0f, 1.0f, 0.0f), 4.0f);
	// debug yellow line (drawn as global space, for debug)
	glm::vec3 debug_Vck_global = (*pc) - (*jk);
	glm::vec3 debug_Vdk_global = (*pd) - (*jk);
	glm::vec3 debug_n_Vck_global = glm::normalize(debug_Vck_global);
	glm::vec3 debug_n_Vdk_global = glm::normalize(debug_Vdk_global);
	glm::vec3 debugNormal_global = glm::cross(debug_n_Vdk_global, debug_n_Vck_global);
	glm::vec3 n_debugNormal_global = glm::normalize(debugNormal_global);


	glm::vec3 debugNormalLocation = ((*jk) + (*normal));
	(*links)[(*k)]->GetGLObject()->DrawLine((*jk),
		debugNormalLocation, glm::vec3(1.0f, 1.0f, 0.0f), 4.0f);
	// end debug vectors
}

