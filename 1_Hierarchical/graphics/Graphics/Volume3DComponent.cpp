// Volume3DComponent.CPP
// Implementation autogenerated by MJEngine automation tools
// WARNING: Do not modify autogenerated comments, automation 
// tools depend on them.

// Edition author: mzaldivar

#include "Volume3DComponent.h"
#include "Transform.h"
#include "TransformComponent.h"
#include "GameObject.h"
#include "ResourceManager.h"
#include <sstream>

extern ResourceManager* resourceManager;

Volume3DComponent::Volume3DComponent()
{
}


Volume3DComponent::~Volume3DComponent()
{
}


bool Volume3DComponent::Init()
{
	// TODO - Implement initializations here
	// This function runs once when object manager
	// load objects, before serialization
	transLoc = GetOwner()->FindComponent<TransformComponent>();
	trans = GetOwner()->GetGLObject()->Transform;
	glm::vec3 rotationAxis = trans->VQS_RotatorForBone.GetCurrentAxis();
	glm::vec3 globalX = glm::vec3(1.0f, 0.0f, 0.0f);

	ball = resourceManager->GetGameObjectByName("Target");
	ballTransform = ball->FindComponent<TransformComponent>();
	ballTrans = ball->GetGLObject()->Transform;

	activateVolume = false;
	return true;
}


void Volume3DComponent::Update()
{
	// TODO - Implement all the updates here
	// This function is executed once everyframe

	glm::mat4 rotMatrix = trans->VQS_RotatorForBone.ToMatrix();
	glm::mat4 ballRotMatrix = ballTrans->VQS_ModelToWorld.Rotator.ToMatrix();

	// my location & direction
	glm::vec3 location = transLoc->GetPosition();
	glm::vec3 fwrdVec = glm::vec3(
		glm::vec4(1.0f, 0.0f, 0.0f, 0.0f) * rotMatrix);
	glm::vec3 rightVec = glm::vec3(
		glm::vec4(0.0f, 0.0f, 1.0f, 0.0f) * rotMatrix);
	glm::vec3 leftVec = glm::vec3(
		glm::vec4(0.0f, 0.0f, -1.0f, 0.0f) * rotMatrix);
	
	//glm::vec3 fwrdVecRelative = location + fwrdVec;

	// ball location
	glm::vec3 ballLocation = ballTransform->GetPosition();

	GLObject* glo = GetOwner()->GetGLObject();

	GetOwner()->GetGLObject()->DrawLine(ballLocation,
		glo->Transform->Position, glm::vec3(1.0f, 1.0f, 0.0f), 1.0f);

	// draw debug forward vector (green)
	glm::vec3 Pa = glo->Transform->Position;
	float t = 5.0f;
	glm::vec3 Va = fwrdVec;
	glm::vec3 castedFwd = Pa + t*Va;
	GetOwner()->GetGLObject()->DrawLine(castedFwd,
		glo->Transform->Position, glm::vec3(0.0f, 1.0f, 1.0f), 1.0f);

	// ears line color
	glm::vec3 earsColor;
	float earsWidth;
	if (activateVolume)
	{
		earsColor = glm::vec3(1.0f, 0.5f, 1.0f);
		earsWidth = 5.0f;
	}
	else
	{
		earsColor = glm::vec3(1.0f, 0.0f, 0.0f);
		earsWidth = 1.0f;
	}
		

	// draw debug right vector
	Pa = glo->Transform->Position;
	t = 5.0f;
	Va = rightVec;
	glm::vec3 castedRight = Pa + t*Va;
	GetOwner()->GetGLObject()->DrawLine(castedRight,
		glo->Transform->Position, earsColor, earsWidth);

	// draw debug left vector
	Pa = glo->Transform->Position;
	t = 5.0f;
	Va = leftVec;
	glm::vec3 castedLeft = Pa + t*Va;
	GetOwner()->GetGLObject()->DrawLine(castedLeft,
		glo->Transform->Position, earsColor, earsWidth);

	// ball fwd vector
	// draw debug forward vector (green)
	glm::vec3 Pb = ballLocation;
	float tb = 1.0f;
	glm::vec3 fwrdVecBall = glm::vec3(
		glm::vec4(1.0f, 0.0f, 0.0f, 0.0f) * ballRotMatrix);
	glm::vec3 Vb = fwrdVecBall;
	glm::vec3 castedFwdBall = Pb + tb*Vb;

	GetOwner()->GetGLObject()->DrawLine(castedFwdBall,
		ballTrans->Position, glm::vec3(1.0f, 0.5f, 0.5f), 5.0f, 
		ballTrans->Position, false);


	glm::vec3 ballVelocity = glm::vec3(1.5f, 0.0f, 0.0f);
	glm::vec3 userHead = location;
	glm::vec3 userForward = fwrdVec;
	float leftEarVolume = 0;
	float rightEarVolume = 0;

	

	activateVolume = computeVolumeEars(ballLocation, ballVelocity, userHead, userForward,
		leftEarVolume, rightEarVolume);


	return;
}

bool Volume3DComponent::computeVolumeEars(glm::vec3 ballPos, glm::vec3 ballVelo,
	glm::vec3 userHead, glm::vec3 userForward,
	float& leftEarvolume, float& rightEarVolume)
{
	// ball is in sound detection area
	float areaRadius = 5.0f;
	float maxRadius = 2.5f; // the distance of the ear from the head center
	float minRadius = 0.1f;
	glm::vec3 C = transLoc->GetPosition(); // center of head
	glm::vec3 B = ballTransform->GetPosition(); // center of ping pong ball

	glm::vec3 CB = B - C;
	float ballDistanceToListener = sqrtf((B.x - C.x)*(B.x - C.x) +
		(B.y - C.y)*(B.y - C.y) + (B.z - C.z)*(B.z - C.z));


	bool isInSoundArea = ballDistanceToListener <= areaRadius;

	if (!isInSoundArea)
		return false;

	float PI = 3.14159265f;

	float A = 0;
	if (ballDistanceToListener <= maxRadius)
		A = 1 / ballDistanceToListener;	// this is the power of the sound
										//, relative to the distance


	// in the horizontal plane (azimuthal angle)
	// relative to the direction of the listener
	glm::vec3 Pah = glm::vec3(ballPos.x, ballPos.y, ballPos.z);
	glm::vec3 Fah = userForward;

	// normalize the vectors
	Pah = Pah / (sqrtf(Pah.x*Pah.x + Pah.z*Pah.z));
	Fah = Fah / (sqrtf(Fah.x*Fah.x + Fah.z*Fah.z));

	// Angle in radians
	float Os =
		acosf(Pah.x*Fah.x + Pah.z*Fah.z) * (180.0f / PI); 


	if (ballPos.z <= 0)
		Os = -Os;


	// Now that we have the angle with the direction vector, 
	// we find a percentage of the angle (B) according to the
	// angle between left and right ears
	float a = (Os + 90.0f) / 180.0f; // left and right ears are always separated by 180 degrees

									 // Now we define the volume of right ear (A1) and left ear (A2)
	float A1 = sinf((0.5f*PI*a)) * A;
	float A2 = cosf((0.5f*PI*a)) * A;

	// test if ratio is ok
	float Ares = sinf((0.5f*PI*a)) * sinf((0.5f*PI*a)) + cosf((0.5f*PI*a)) * cosf((0.5f*PI*a));
	bool ok = Ares >= 0.999f;

	// assign volumes
	rightEarVolume = A1;
	leftEarvolume = A2;

	// if we want the frecuency of the sound wave, then:
	float c = 340.29f * 0.16f; // speed of sound times deltatime
	glm::vec3 headVelo = glm::vec3(1.0f, 0.0f, 0.0f); // assume any constant for this exam
	float headVeloMagnitude = sqrt(headVelo.x*headVelo.x +
		headVelo.y*headVelo.y + headVelo.z*headVelo.z);
	float ballVeloMagnitude = sqrt(ballVelo.x*ballVelo.x +
		ballVelo.y*ballVelo.y * ballVelo.z*ballVelo.z);
	float F = (c + headVeloMagnitude) / (c + ballVeloMagnitude);
	float F1 = A1 * F;
	float F2 = A2 * F;

	// print the volumes, to check
	std::cout << "-------------------------------" << std::endl;
	std::cout << "Ball Distance: " << ballDistanceToListener << std::endl;
	std::cout << "Os: " << Os << std::endl;
	std::cout << "Left Ear Vol: " << leftEarvolume << std::endl;
	std::cout << "Right Ear Vol: " << rightEarVolume << std::endl;

	return true;
}


void Volume3DComponent::HandleEvent(const Event* const evt)
{
	// TODO - Implement reactions to different events
}

void Volume3DComponent::CompleteExtraSetup()
{
	// TODO - Implement any setup that needs to be executed
	// after the owner gameobject already exists.
}


// private functions
bool Volume3DComponent::isCloseEnough(glm::vec3 objLocation)
{

	// implement ball moving alone, using velocity
	float areaRadius = 5.0f;
	glm::vec3 C = transLoc->GetPosition(); // center of head
	glm::vec3 B = ballTransform->GetPosition(); // center of ping pong ball

	glm::vec3 CB = B - C;
	float CB_Magnitude = (B.x - C.x)*(B.x - C.x) +
		(B.y - C.y)*(B.y - C.y) + (B.z - C.z)*(B.z - C.z);

	//bool isSoundArea = (sqrt(CB_Magnitude) - areaRadius) <= 0.0f; // Dmax
	bool isSoundArea = CB_Magnitude <= areaRadius * areaRadius;
	return isSoundArea;
}

