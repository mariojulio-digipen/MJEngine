// UIUpdaterComponent.CPP
// Implementation autogenerated by MJEngine automation tools
// WARNING: Do not modify autogenerated comments, automation 
// tools depend on them.

// Edition author: mzaldivar

#include "UIUpdaterComponent.h"
#include "GameObject.h"
#include "TransformComponent.h"
#include "LightPointComponent.h"
#include "VQS.h"
#include "Event.h"
#include "EventManager.h"

#include <sstream>
#include <gtc\matrix_transform.hpp>
#include <gtx\euler_angles.hpp>
#include <glm.hpp>

extern UIManager* uiManager;
//extern EventManager* eventManager;

UIUpdaterComponent::UIUpdaterComponent()
{
}


UIUpdaterComponent::~UIUpdaterComponent()
{
}


bool UIUpdaterComponent::Init()
{
	// TODO - Implement initializations here
	// This function runs once when object manager
	// load objects, before serialization
	trans = GetOwner()->FindComponent<TransformComponent>();
	lightComp = GetOwner()->FindComponent<LightPointComponent>();

	pushed = false;
	return true;
}


void UIUpdaterComponent::Update()
{
	// TODO - Implement all the updates here
	// This function is executed once everyframe

	/*if (this->GetOwner()->GetName() == "Ball")
		return;*/

	float startScale = 0.0f;

	if (!pushed)
	{
		// push
		vec = new ImVec4(
			trans->GetPosition().x, 
			trans->GetPosition().y, 
			trans->GetPosition().z, 1.0f);
		uiManager->ObjectsPosition.push_back((vec));

		rot = new ImVec4(
			trans->GetRotation().x,
			trans->GetRotation().y,
			trans->GetRotation().z, 1.0f);
		uiManager->ObjectsRotation.push_back((rot));

		

		//if (GetOwner()->GetName() == "Hips")
		if (GetOwner()->GetGLObject()->Bonetype == BONE_TYPE::ROOT &&
			GetOwner()->IsBone)
		{
			sca = new ImVec4(
				0.144f,
				0.144f,
				0.144f, 1.0f);
				//(*vec).x,
				//(*vec).y,
				//(*vec).z, 1.0f);
			uiManager->ObjectsScale.push_back((sca));
		}
		else
		{
			sca = new ImVec4(
				trans->GetScale().x,
				trans->GetScale().y,
				trans->GetScale().z, 1.0f);
			uiManager->ObjectsScale.push_back((sca));
			startScale = trans->GetScale().x;
		}
		

		if (lightComp)
		{
			lightColor = new ImVec4(
				lightComp->GetLightColor().r,
				lightComp->GetLightColor().g,
				lightComp->GetLightColor().b, 1.0f);
		}
		else
		{
			lightColor = new ImVec4(
				0.0f,
				0.0f,
				0.0f, 1.0f);
		}
		uiManager->ObjectsLightColor.push_back((lightColor));
		
		uiManager->ObjectsName.push_back(GetOwner()->GetName());
		pushed = true;
	}
	else
	{
		glm::vec3 axis_converted;
		// Use root node instead the name
		//if (GetOwner()->GetName() == "Hips")

		if (GetOwner()->GetName() != "Target")
		{
			if (GetOwner()->GetGLObject()->Bonetype == BONE_TYPE::ROOT)
			{
				trans->SetPosition(glm::vec3((*vec).x, (*vec).y, (*vec).z)*0.001f);
				glm::mat4 T = glm::translate(glm::mat4(1.0f), trans->GetPosition());
				GetOwner()->GetGLObject()->Transform->TranslateForBoneMatrix = T;
			}
			else
			{
				trans->SetPosition(glm::vec3((*vec).x, -(*vec).z, (*vec).y));
				glm::mat4 T = glm::translate(glm::mat4(1.0f), trans->GetPosition());
				GetOwner()->GetGLObject()->Transform->TranslateForBoneMatrix = T;
			}
		}
		

		

		// send updated vqs translator
		if (GetOwner()->GetName() != "Target")
		{
			glm::vec3 VQS_T = trans->GetPosition();
			GetOwner()->GetGLObject()->Transform->VQS_TranslatorForBone = VQS_T;
		}
		






		glm::mat4 rotM, invRotM;
		if (GetOwner()->GetGLObject()->Bonetype == BONE_TYPE::ROOT)
		{
			trans->SetRotation(glm::vec3((*rot).x, (*rot).z, (*rot).y));
			glm::mat4 R = glm::eulerAngleXYZ
			(
				trans->GetRotation().x,
				trans->GetRotation().y,
				trans->GetRotation().z
			);
			//GetOwner()->GetGLObject()->Transform->RotationForBoneMatrix = R;
			rotM = R;
		}
		else
		{
			trans->SetRotation(glm::vec3((*rot).x, (*rot).y, (*rot).z));
			glm::mat4 R = glm::eulerAngleXYZ
			(
				trans->GetRotation().x,
				trans->GetRotation().y,
				trans->GetRotation().z
			);
			//GetOwner()->GetGLObject()->Transform->RotationForBoneMatrix = R;
			rotM = R;
		}


		if (trans->GetOwner()->GetName() == "LeftArm")
		{
			int a = 0;
			a++;
		}


		//invRotM = glm::inverse(rotM);

		//Quaternion VQS_Q = Quaternion::QuatFromMatrix(&rotM);
		

		// send updated vqs rotator
		Quaternion VQS_Q = Quaternion::QuatFromAngles(
			glm::vec3(glm::radians(trans->GetRotation().x), 
				glm::radians(trans->GetRotation().z), 
				glm::radians(trans->GetRotation().y))
		);
		
		GetOwner()->GetGLObject()->Transform->VQS_RotatorForBone = VQS_Q;

		// send updated vqs scaler
		/*if (GetOwner()->GetGLObject()->Bonetype == BONE_TYPE::ROOT)
		{
			trans->SetScale(glm::vec3((*sca).x, (*sca).y, (*sca).z));
			if (trans->GetScale().x == 0.0f)
				GetOwner()->GetGLObject()->Transform->VQS_ScalerForBone = 1.0f;
			else
				GetOwner()->GetGLObject()->Transform->VQS_ScalerForBone = trans->GetScale().x;
		}
		else
		{
			GetOwner()->GetGLObject()->Transform->VQS_ScalerForBone = 1.0f;
		}*/
		

		if (lightComp)
		{
			// send updated light color
			lightComp->SetLightColor(glm::vec3((*lightColor).x, (*lightColor).y, (*lightColor).z));
		}
		
	}
}

void UIUpdaterComponent::HandleEvent(const Event * const evt)
{
	/*const StopMovingAlongPath* stopAlong =
		dynamic_cast<const StopMovingAlongPath*>(evt);
	if (stopAlong != NULL)
	{
		glm::vec3 stopLocation = stopAlong->GetStopLocation();
		(*vec).x = stopLocation.x;
		(*vec).y = stopLocation.y;
		(*vec).z = stopLocation.z;

		glm::vec3 stopRotation = stopAlong->GetStopRotation();
		(*rot).x = stopRotation.x;
		(*rot).y = stopRotation.y;
		(*rot).z = stopRotation.z;

		glm::vec3 stopScale = stopAlong->GetStopScale();
		(*sca).x = stopScale.x;
		(*sca).y = stopScale.y;
		(*sca).z = stopScale.z;
	}*/
}

void UIUpdaterComponent::Destroy()
{
	delete vec;
	delete rot;
	delete sca;
}
