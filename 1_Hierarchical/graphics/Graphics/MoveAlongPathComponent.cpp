// MoveAlongPathComponent.CPP
// Implementation autogenerated by MJEngine automation tools
// WARNING: Do not modify autogenerated comments, automation 
// tools depend on them.

// Edition author: mzaldivar

#include "MoveAlongPathComponent.h"
#include "Event.h"
#include "EventManager.h"
#include "GameObject.h"
#include "GLObject.h"
#include "TransformComponent.h"
#include "Spline.h"
#include "FrameRateController.h"
#include "UIManager.h"

#include <sstream>
#include <vector>
#include <glm.hpp>
#include <gtc\matrix_transform.hpp>

extern FrameRateController* frameRateController;
extern UIManager* uiManager;
extern EventManager* eventManager;

MoveAlongPathComponent::MoveAlongPathComponent() : moving(false)
{
}


MoveAlongPathComponent::~MoveAlongPathComponent()
{
}


bool MoveAlongPathComponent::Init()
{
	// TODO - Implement initializations here
	// This function runs once when object manager
	// load objects, before serialization
	ownerTrans = GetOwner()->FindComponent<TransformComponent>();
	return true;
}


void MoveAlongPathComponent::Update()
{
	// TODO - Implement all the updates here
	// This function is executed once everyframe
	glm::vec3 point;
	if (!moving)
	{
		point = glm::vec3(0.0f, 0.0f, 0.0f);
		return;
	}
		

	float delta = frameRateController->DeltaTime;


	// Query a point in the space curve so that this point will be the new
	//position of the character in the path.
	double s_t = 
		spline->DistanceTimeControlledPeace(delta, 5.0f/*uiManager->PathPeace*/, 0.05, 0.35);
	
	glm::vec3 COI;
	glm::vec3 globalY = glm::vec3(0.0f, 1.0f, 0.0);
	glm::vec3 globalX = glm::vec3(1.0f, 0.0f, 0.0);
	if (s_t > 0.99)
	{
		IKGrabTarget* createIKEvt =
			eventManager->GenerateEvent<IKGrabTarget>();
		eventManager->BroadCastEvent(createIKEvt);
		moving = false;

		StopMovingAlongPath* stopAlongEvent =
			eventManager->GenerateEvent<StopMovingAlongPath>();
		/*stopAlongEvent->SetLastLocation(ownerTrans->GetPosition());
		stopAlongEvent->SetLastRotation(ownerTrans->GetRotation());
		stopAlongEvent->SetLastScale(ownerTrans->GetScale());*/

		eventManager->BroadCastEvent(stopAlongEvent);
		std::cout << "creando evento de stop!" << std::endl;
		return;
	}
	
	double u_s = spline->UatCurveDistance(s_t);
	point = spline->GetPointPu(u_s);
	ownerTrans->SetPosition(point);

	glm::mat4 T = glm::translate(glm::mat4(1.0f), ownerTrans->GetPosition());
	GetOwner()->GetGLObject()->Transform->TranslateForBoneMatrix = T;

	// send updated vqs translator
	glm::vec3 VQS_T = ownerTrans->GetPosition();
	GetOwner()->GetGLObject()->Transform->VQS_TranslatorForBone = VQS_T;

	// send updated vqs rotator
	double jump = 0.0005;


	// Quaternion approach for orientation control
	double current_t = spline->GetCurrentTime();

	double delta_s_t = 0.0000;
	double delta_u_s = 0.0000;
	
	delta_s_t = spline->DistanceTime(current_t + jump*40, delta, 0.05, 0.35);

	
	if (delta_s_t > 1.0000)
		return;
	delta_u_s = spline->UatCurveDistance(delta_s_t);
	COI = spline->GetPointPu(delta_u_s);
	glm::vec3 W = COI - point;
	W = glm::normalize(W);

	glm::vec3 U = glm::cross(globalY, W);
	U = glm::normalize(U);
	glm::vec3 V = glm::cross(W, U);
	V = glm::normalize(V);


	float cosine;
	float arccosine;
	float angle;
	if (W.z < 0.0000)
	{
		cosine = glm::dot(W, globalX);
		arccosine = glm::acos(cosine);
		angle = glm::degrees(arccosine);
	}
		
	else
	{
		cosine = glm::dot(W, -globalX);
		arccosine = -glm::acos(cosine);
		angle = 180.0f - glm::degrees(arccosine);
	}
	

	Quaternion VQS_Q = Quaternion::QuatFromAngles(
		glm::vec3(glm::radians(0.0f),
			glm::radians(angle),
			0.0f)
	);

	
	/*if (current_t >= 0.99 || current_t <= 0.01)
	{
		GetOwner()->GetGLObject()->DrawLine(COI, point,
			glm::vec3(0.0f, 1.0f, 1.0f), 20.0f,
			glm::vec3(0.0f, 2.0f, 0.0f), true);
	}*/

	VQS_Q.Normalize();
	GetOwner()->GetGLObject()->Transform->VQS_RotatorForBone = VQS_Q;

	return;
}


void MoveAlongPathComponent::Destroy()
{
	// TODO - Optional, use to release memory
	// This function is called by the user.
}


void MoveAlongPathComponent::HandleEvent(const Event* const evt)
{
	// TODO - Implement reactions to different events

	const StartMovingAlongPath* moveAlong =
		dynamic_cast<const StartMovingAlongPath*>(evt);
	if (moveAlong != NULL)
	{
		moving = true;
		spline = moveAlong->GetPath();
	}
		
	const StopMovingAlongPath* stopAlong =
		dynamic_cast<const StopMovingAlongPath*>(evt);
	if (stopAlong != NULL)
	{
		moving = false;
	}

	const CreateControlPoint* cpEvt =
		dynamic_cast<const CreateControlPoint*>(evt);
	if (cpEvt)
	{
		GameObject* go = cpEvt->GetPoint();
		if (go->IsAlive)
		{
			lastOffsetCP = cpEvt->GetPoint()->GetGLObject()->
				Transform->Position;
		}
	}
	
}

