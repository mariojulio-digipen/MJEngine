// ClothComponent.CPP
// Implementation autogenerated by MJEngine automation tools
// WARNING: Do not modify autogenerated comments, automation 
// tools depend on them.

// Edition author: mzaldivar
#include "ImGui\imgui.h"
#include "ClothComponent.h"
#include "TransformComponent.h"
#include "GLObject.h"
#include "Shader.h"
#include "Pyshics3DManager.h"
#include "RenderManager.h"
#include "Render3D.h"
#include "ResourceManager.h"
#include "UIManager.h"

#include <sstream>
#include <gtc\matrix_transform.hpp>

#define SQRT2 1.414213562373f

extern Pyshics3DManager* physics3DManager;
extern Shader* shader;
extern RenderManager* renderManager;
extern UIManager* uiManager;
extern ResourceManager* resourceManager;

ClothComponent::ClothComponent()
{
	
}


ClothComponent::~ClothComponent()
{
}


bool ClothComponent::Init()
{
	// TODO - Implement initializations here
	// This function runs once when object manager
	// load objects, before serialization
	trans = GetOwner()->FindComponent<TransformComponent>();
	return true;
}


void ClothComponent::Update()
{
	// TODO - Implement all the updates here
	// This function is executed once everyframe
	
	if (!buffersReady)
	{
		// initialize graphics cloth graphics
		createTexture();
		createGLBuffers();
		buildClothVBOs();
		buffersReady = true;
	}

	// When this function is called, all the new position and velocity info
	// is already computed by the physics manager,
	// with that info, we can render the particle grid.

	int max_x, max_z;
	max_x = this->cols - 1;
	max_z = this->rows - 1;
	glm::vec3 loct = glm::vec3(uiManager->Stick1LocationX, uiManager->Stick1LocationY, uiManager->Stick1LocationZ);
	particleGrid[0][0]->location = loct;
	/*particleGrid[0][max_x]->location = loct;
	particleGrid[max_z][0]->location = loct;
	particleGrid[max_x][max_z]->location = loct;*/

	// update isFixed property of particles accordingly
	updateGridStickPoints();

	// update triangles data buffers
	//particleGrid[0][0]->location.y -= 5.0f * 0.016f;
	updateTrianglesData();

	// render particle grid with new positions
	drawCloth();

}


void ClothComponent::Serialize(std::istringstream* objcontentStream)
{
	std::string line;
	std::getline((*objcontentStream), line);

	std::istringstream lineStream(line.c_str());
	std::string word;

	while ((*objcontentStream) >> word)
	{
		if (word == "#")
		{
			std::getline((*objcontentStream), line);
			continue;
		}
		
		// TODO - Implement more if statements according to the file format
		// This function runs right after the Init function
		if (word == "dim")
		{
			std::getline((*objcontentStream), line);
			sscanf_s(line.c_str(), "%i %i", &this->cols, &this->rows);
			continue;
		}

		if (word == "space")
		{
			std::getline((*objcontentStream), line);
			float space = (float)atof(line.c_str());
			this->spaceBetweenParticles = space;
			continue;
		}

		if (word == "mass")
		{
			std::getline((*objcontentStream), line);
			float m = (float)atof(line.c_str());
			this->mass = m;
			continue;
		}

		if (word == "k")
		{
			std::getline((*objcontentStream), line);
			float k = (float)atof(line.c_str());
			this->k = k;
			continue;
		}

		/*if (word == "l")
		{
			std::getline((*objcontentStream), line);
			float l = (float)atof(line.c_str());
			this->l = l;
			continue;
		}*/
	}
}


void ClothComponent::HandleEvent(const Event* const evt)
{
	// TODO - Implement reactions to different events
}

void ClothComponent::CompleteExtraSetup()
{
	if (!physics3DManager) return;
	targetSphereTrans = resourceManager->GetGameObjectByName("Target")->FindComponent<TransformComponent>();
	physics3DManager->SetTestTargeTrans(targetSphereTrans);
	/*physics3DManager->SetTestTargetLocation(&targetSphereTrans->GetPosition());
	physics3DManager->SetTestTargeScale(&targetSphereTrans->GetScale());*/

	// reserve memory for the particles grid
	std::vector<Particle*> datacurr(rows, NULL);
	particleGrid.resize(cols, datacurr);

	std::vector<Particle*> datanext(rows, NULL);
	particleGridNextFrame.resize(cols, datanext);


	init2DGrid();




	
}


//                        //
// private functions here //
//						  //

void ClothComponent::updateGridStickPoints()
{
	// update the cloth's corners
	int max_x, max_z;
	max_x = this->cols - 1;
	max_z = this->rows - 1;
	
	if(uiManager->Stick1Released)
		particleGrid[0][0]->isFixed = uiManager->Stick1Released;				// bottom-left
	
	if(uiManager->Stick2Released)
		particleGrid[0][max_x]->isFixed = uiManager->Stick2Released;			// bottom-right
	
	if(uiManager->Stick3Released)
		particleGrid[max_z][0]->isFixed = uiManager->Stick3Released;			// top-left
	
	if(uiManager->Stick4Released)
	particleGrid[max_x][max_z]->isFixed = uiManager->Stick4Released;		// top-right
}

void ClothComponent::init2DGrid()
{
	initParticles();
	initSprings();

	particleGrid;
	springs;

}

void ClothComponent::updateTrianglesData()
{
	this->vertexData.clear();
	this->normalData.clear();

	// set vertices and store new normal values
	for (int i = 0; i < cols - 1; i++)
	{
		for (int j = 0; j < rows - 1; j++)
		{
			glm::vec3 p0 = particleGrid[i][j]->location;
			glm::vec3 p1 = particleGrid[i][j + 1]->location;
			glm::vec3 p2 = particleGrid[i + 1][j]->location;
			glm::vec3 p3 = particleGrid[i + 1][j + 1]->location;

			glm::vec3 vertex1 = p0;
			glm::vec3 vertex2 = p1;
			glm::vec3 vertex3 = p2;
			glm::vec3 vertex4 = p2;
			glm::vec3 vertex5 = p3;
			glm::vec3 vertex6 = p1;

			//glm::vec3 n0, n1, n2, n3;

			//glm::vec3 normal = glm::cross(p1 - p0, p2 - p0);//(p1 - p0).CrossProduct(p2 - p0);

			//n0 += normal;
			//n1 += normal;
			//n2 += normal;

			//normal = glm::cross(p1 - p2, p3 - p2);//(p1 - p2).CrossProduct(p3 - p2);

			//n1 += normal;
			//n2 += normal;
			//n3 += normal;

			glm::vec3 v1, v2; 
			v1 = p1 - p0;
			v2 = p2 - p0;
			glm::vec3 n0 = glm::cross(v1, v2);
			v1 = p0 - p1;
			v2 = p3 - p1;
			glm::vec3 n1 = glm::cross(v2, v1);
			v1 = p2 - p3;
			v2 = p1 - p3;
			glm::vec3 n2 = glm::cross(v1, v2);
			v1 = p3 - p2;
			v2 = p0 - p2;
			glm::vec3 n3 = glm::cross(v2, v1);

			glm::vec3 normal1 = glm::normalize(n0);
			glm::vec3 normal2 = glm::normalize(n1);
			glm::vec3 normal3 = glm::normalize(n2);
			glm::vec3 normal4 = glm::normalize(n2);
			glm::vec3 normal5 = glm::normalize(n3);
			glm::vec3 normal6 = glm::normalize(n1);


			//glm::vec3 n1 = particleGrid[i][j]->normal += normal1; // p0
			//glm::vec3 n2 = particleGrid[i][j + 1]->normal += normal2; // p1
			//glm::vec3 n3 = particleGrid[i + 1][j]->normal += normal3; // p2
			//glm::vec3 n4 = particleGrid[i + 1][j + 1]->normal += normal4; // p3


			this->vertexData.push_back(vertex1.x); this->vertexData.push_back(vertex1.y); this->vertexData.push_back(vertex1.z);
			this->normalData.push_back(normal1.x); this->normalData.push_back(normal1.y); this->normalData.push_back(normal1.z);

			this->vertexData.push_back(vertex2.x); this->vertexData.push_back(vertex2.y); this->vertexData.push_back(vertex2.z);
			this->normalData.push_back(normal2.x); this->normalData.push_back(normal2.y); this->normalData.push_back(normal2.z);

			this->vertexData.push_back(vertex3.x); this->vertexData.push_back(vertex3.y); this->vertexData.push_back(vertex3.z);
			this->normalData.push_back(normal3.x); this->normalData.push_back(normal3.y); this->normalData.push_back(normal3.z);

			this->vertexData.push_back(vertex4.x); this->vertexData.push_back(vertex4.y); this->vertexData.push_back(vertex4.z);
			this->normalData.push_back(normal4.x); this->normalData.push_back(normal4.y); this->normalData.push_back(normal4.z);

			this->vertexData.push_back(vertex5.x); this->vertexData.push_back(vertex5.y); this->vertexData.push_back(vertex5.z);
			this->normalData.push_back(normal5.x); this->normalData.push_back(normal5.y); this->normalData.push_back(normal5.z);

			this->vertexData.push_back(vertex6.x); this->vertexData.push_back(vertex6.y); this->vertexData.push_back(vertex6.z);
			this->normalData.push_back(normal6.x); this->normalData.push_back(normal6.y); this->normalData.push_back(normal6.z);

		}
	}

	
	// set normals values
	/*for (int i = 0; i < cols - 1; i++)
	{
		for (int j = 0; j < rows - 1; j++)
		{
			glm::vec3 n = particleGrid[i][j]->normal;
			this->normalData.push_back(n.x);
			this->normalData.push_back(n.y);
			this->normalData.push_back(n.z);
		}
	}*/

}

void ClothComponent::createTrianglesData()
{
	for (int i = 0; i < cols - 1; i++)
	{
		for (int j = 0; j < rows - 1; j++)
		{
			glm::vec3 p0 = particleGrid[i][j]->location;
			glm::vec3 p1 = particleGrid[i][j + 1]->location;
			glm::vec3 p2 = particleGrid[i + 1][j]->location;
			glm::vec3 p3 = particleGrid[i + 1][j + 1]->location;

			// triangles using: 
			// p0 -> p1 -> p2
			// p2 -> p3 -> p1
			glm::vec3 vertex1 = p0; vertexNumber++;
			glm::vec3 vertex2 = p1; vertexNumber++;
			glm::vec3 vertex3 = p2; vertexNumber++;
			glm::vec3 vertex4 = p2; vertexNumber++;
			glm::vec3 vertex5 = p3; vertexNumber++;
			glm::vec3 vertex6 = p1; vertexNumber++;

			this->vertexData.push_back(vertex1.x); this->vertexData.push_back(vertex1.y); this->vertexData.push_back(vertex1.z);
			this->textureData.push_back(0.0f); this->textureData.push_back(0.0f);
			this->normalData.push_back(0.0f); this->normalData.push_back(1.0f); this->normalData.push_back(0.0f);

			this->vertexData.push_back(vertex2.x); this->vertexData.push_back(vertex2.y); this->vertexData.push_back(vertex2.z);
			this->textureData.push_back(0.0f); this->textureData.push_back(1.0f);
			this->normalData.push_back(0.0f); this->normalData.push_back(1.0f); this->normalData.push_back(0.0f);

			this->vertexData.push_back(vertex3.x); this->vertexData.push_back(vertex3.y); this->vertexData.push_back(vertex3.z);
			this->textureData.push_back(1.0f); this->textureData.push_back(0.0f);
			this->normalData.push_back(0.0f); this->normalData.push_back(1.0f); this->normalData.push_back(0.0f);

			this->vertexData.push_back(vertex4.x); this->vertexData.push_back(vertex4.y); this->vertexData.push_back(vertex4.z);
			this->textureData.push_back(1.0f); this->textureData.push_back(0.0f);
			this->normalData.push_back(0.0f); this->normalData.push_back(1.0f); this->normalData.push_back(0.0f);

			this->vertexData.push_back(vertex5.x); this->vertexData.push_back(vertex5.y); this->vertexData.push_back(vertex5.z);
			this->textureData.push_back(1.0f); this->textureData.push_back(1.0f);
			this->normalData.push_back(0.0f); this->normalData.push_back(1.0f); this->normalData.push_back(0.0f);

			this->vertexData.push_back(vertex6.x); this->vertexData.push_back(vertex6.y); this->vertexData.push_back(vertex6.z);
			this->textureData.push_back(0.0f); this->textureData.push_back(1.0f);
			this->normalData.push_back(0.0f); this->normalData.push_back(1.0f); this->normalData.push_back(0.0f);

		}
	}
}

void ClothComponent::initParticles()
{
	if (!physics3DManager) return;
	// initialize particles
	int particleId = 0;
	for (int i = 0; i < cols; i++)
	{
		for (int j = 0; j < rows; j++)
		{
			// data
			Particle* particle = new Particle;
			particle->id = particleId;
			particle->location.x = trans->GetPosition().x + spaceBetweenParticles * i;  // [0..1]
			particle->location.y = trans->GetPosition().y;												// [0..1]
			particle->location.z = trans->GetPosition().z + spaceBetweenParticles * j;	// [0..1]
			particle->mass = this->mass;
			particle->isFixed = false;
			particle->velocity = glm::vec3(0.0f);
			//particle->SetTotalForce(glm::vec3(0.0f));
			particle->normal = glm::vec3(0.0f, 1.0f, 0.0f); // rest position is always a plane parallel to the floor.
			particleId++;
			physics3DManager->ManageThisParticle(particle);
			particleGrid[i][j] = particle;

		}
	}

	// fix the cloth's corners
	int max_x, max_z;
	max_x = this->cols - 1;
	max_z = this->rows - 1;
	//ImVec4* loc = new ImVec4(particleGrid[0][0]->location.x, particleGrid[0][0]->location.y, particleGrid[0][0]->location.z, 1.0f);
	//uiManager->Stick1Location = loc;
	uiManager->Stick1LocationX = particleGrid[0][0]->location.x;
	uiManager->Stick1LocationY = particleGrid[0][0]->location.y;
	uiManager->Stick1LocationZ = particleGrid[0][0]->location.z;
	//particleGrid[0][0]->location = 
	particleGrid[0][0]->isFixed = true;				// bottom-left
	particleGrid[0][max_x]->isFixed = true;			// bottom-right
	particleGrid[max_z][0]->isFixed = true;			// top-left
	particleGrid[max_x][max_z]->isFixed = true;		// top-right


	createTrianglesData();


}

void ClothComponent::initSprings()
{
	if (!physics3DManager) return;
	// all rows
	// --------
	// --------
	// --------
	// --------
	// --------

	for (int i = 0; i < rows; i++)
	{
		for (int j = 0; j < cols - 1; j++)
		{
			Spring* spring = new Spring;
			spring->k = this->k;
			spring->naturalLength = this->spaceBetweenParticles;
			/*spring->particle1 = particleGrid[i][j];
			spring->particle2 = particleGrid[i][j+1];*/
			spring->particleId1 = particleGrid[i][j]->id;
			spring->particleId2 = particleGrid[i][j + 1]->id;
			springs.push_back(spring);
			physics3DManager->ManageThisSpring(spring);
			//std::cout << "(" << i << ", " << j + 1 << ") --- ";

			// debug data
			/*spring->p1GridPos = glm::vec2(i, j);
			spring->p2GridPos = glm::vec2(i, j + 1);*/
		}
	}

	std::cout << std::endl;

	// all cols
	// |||||||||
	// |||||||||
	// |||||||||
	// |||||||||
	// |||||||||
	
	for (int i = 0; i < cols; i++)
	{
		for (int j = 0; j < rows - 1; j++)
		{
			Spring* spring = new Spring;
			spring->k = this->k;
			spring->naturalLength = this->spaceBetweenParticles;
			/*spring->particle1 = particleGrid[j][i];
			spring->particle2 = particleGrid[j+1][i];*/
			spring->particleId1 = particleGrid[j][i]->id;
			spring->particleId2 = particleGrid[j + 1][i]->id;
			springs.push_back(spring);
			physics3DManager->ManageThisSpring(spring);
			//std::cout << "(" << j << ", " << i << ")" << std::endl;
			//std::cout << "|" << std::endl;

			// debug data
			/*spring->p1GridPos = glm::vec2(j, i);
			spring->p2GridPos = glm::vec2(j + 1, i);*/
		}
		std::cout << std::endl;
	}

	// all diagonals 1
	// ////////
	// ////////
	// ////////
	// ////////
	// ////////


	for (int i = 0; i < rows - 1; i++)
	{
		for (int j = 0; j < cols - 1; j++)
		{
			Spring* spring = new Spring;
			spring->k = this->k;
			spring->naturalLength = this->spaceBetweenParticles*SQRT2;
			/*spring->particle1 = particleGrid[i][j];
			spring->particle2 = particleGrid[i + 1][j + 1];*/
			spring->particleId1 = particleGrid[i][j]->id;
			spring->particleId2 = particleGrid[i + 1][j + 1]->id;
			springs.push_back(spring);
			physics3DManager->ManageThisSpring(spring);
			/*std::cout << "(" << i << ", " << j << ")" << " --> " ;
			std::cout << "(" << i + 1 << ", " << j + 1 << ")" << std::endl;*/

			// debug data
			/*spring->p1GridPos = glm::vec2(i, j);
			spring->p2GridPos = glm::vec2(i + 1, j + 1);*/
		}
	}

	std::cout << std::endl;

	// all diagonals 2
	// \\\\\\\\
	// \\\\\\\\
	// \\\\\\\\
	// \\\\\\\\
	// \\\\\\\\

	for (int i = 0; i < rows - 1; i++)
	{
		for (int j = 0; j < cols - 1; j++)
		{
			Spring* spring = new Spring;
			spring->k = this->k;
			spring->naturalLength = this->spaceBetweenParticles*SQRT2;
			/*spring->particle1 = particleGrid[i][j + 1];
			spring->particle2 = particleGrid[i + 1][j];*/
			spring->particleId1 = particleGrid[i][j + 1]->id;
			spring->particleId2 = particleGrid[i + 1][j]->id;
			springs.push_back(spring);
			physics3DManager->ManageThisSpring(spring);
			/*std::cout << "(" << i << ", " << j + 1 << ")" << " --> ";
			std::cout << "(" << i + 1 << ", " << j << ")" << std::endl;*/

			// debug data
			/*spring->p1GridPos = glm::vec2(i, j + 1);
			spring->p2GridPos = glm::vec2(i + 1, j);*/
		}
	}
	std::cout << std::endl;
	// all neighbor's neighbors 1
	// -- -- -- --
	// -- -- -- --
	// -- -- -- --
	// -- -- -- --
	// -- -- -- --
	
	for (int i = 0; i < rows; i++)
	{
		for (int j = 0; j < cols - 2; j++)
		{
			Spring* spring = new Spring;
			spring->k = this->k;
			spring->naturalLength = this->spaceBetweenParticles * 2.0f;
			/*spring->particle1 = particleGrid[i][j];
			spring->particle2 = particleGrid[i][j+2];*/
			spring->particleId1 = particleGrid[i][j]->id;
			spring->particleId2 = particleGrid[i][j + 2]->id;
			springs.push_back(spring);
			physics3DManager->ManageThisSpring(spring);
			/*std::cout << "(" << i << ", " << j << ")" << " --> ";
			std::cout << "(" << i << ", " << j+2 << ")" << std::endl;*/

			// debug data
			/*spring->p1GridPos = glm::vec2(i, j);
			spring->p2GridPos = glm::vec2(i, j + 2);*/
		}
	}
	std::cout << std::endl;
	// all neighbor's neighbors 2
	// |||||||
	// |||||||
	// 
	// |||||||
	// |||||||
	// 
	// |||||||
	// |||||||

	for (int i = 0; i < cols; i++)
	{
		for (int j = 0; j < rows - 2; j++)
		{
			Spring* spring = new Spring;
			spring->k = this->k;
			spring->naturalLength = this->spaceBetweenParticles * 2.0f;
			/*spring->particle1 = particleGrid[j][i];
			spring->particle2 = particleGrid[j + 2][i];*/
			spring->particleId1 = particleGrid[j][i]->id;
			spring->particleId2 = particleGrid[j + 2][i]->id;
			springs.push_back(spring);
			physics3DManager->ManageThisSpring(spring);
			/*std::cout << "(" << j << ", " << i << ")" << " --> ";
			std::cout << "(" << j+2 << ", " << i << ")" << std::endl;*/

			// debug data
			/*spring->p1GridPos = glm::vec2(j, i);
			spring->p2GridPos = glm::vec2(j + 2, i);*/
		}
	}

}


void ClothComponent::computeNormals()
{
	
}




////////graphics////////
void ClothComponent::createTexture()
{
	this->texture = new Texture("ArtAssets\\sample.png");
	texture->Create();
}

void ClothComponent::createGLBuffers()
{
	glGenVertexArrays(1, &clothVAO);
	GLenum err = glGetError();
	glGenBuffers(1, &clothVBO_V);
	glGenBuffers(1, &clothVBO_T);
	glGenBuffers(1, &clothVBO_N);
}

void ClothComponent::deleteGLBuffers()
{
	glDeleteVertexArrays(1, &clothVAO);
	glDeleteBuffers(1, &clothVBO_V);
	glDeleteBuffers(1, &clothVBO_T);
	glDeleteBuffers(1, &clothVBO_N);
}

void ClothComponent::useVAO(GLuint vaoId)
{
	glBindVertexArray(vaoId);
}

void ClothComponent::buildClothVBOs()
{
	// bind the vao of the entire cloth
	GLObject* glo = GetOwner()->GetGLObject();
	glBindVertexArray(clothVAO);
	int sizeInBytes = 0;


	// particles as vertices
	glBindBuffer(GL_ARRAY_BUFFER, clothVBO_V);
	sizeInBytes = (this->vertexNumber * 3) * sizeof(float);
	glBufferData(GL_ARRAY_BUFFER, sizeInBytes, &this->vertexData[0], GL_STATIC_DRAW);
	glEnableVertexAttribArray(positionAttributeIndex);
	glVertexAttribPointer(positionAttributeIndex, 3, GL_FLOAT, GL_FALSE, 0, 0);

	// particles given color for cloth texture
	glBindBuffer(GL_ARRAY_BUFFER, clothVBO_T);
	sizeInBytes = (this->vertexNumber * 2) * sizeof(float);
	glBufferData(GL_ARRAY_BUFFER, sizeInBytes, &this->textureData[0], GL_STATIC_DRAW);
	glEnableVertexAttribArray(uvAttributeIndex);
	glVertexAttribPointer(uvAttributeIndex, 2, GL_FLOAT, GL_FALSE, 0, 0);

	// normals at each particle
	glBindBuffer(GL_ARRAY_BUFFER, clothVBO_N);
	sizeInBytes = (this->vertexNumber * 3) * sizeof(float);
	glBufferData(GL_ARRAY_BUFFER, sizeInBytes, &this->normalData[0], GL_STATIC_DRAW);
	glEnableVertexAttribArray(normalAttributeIndex);
	glVertexAttribPointer(normalAttributeIndex, 3, GL_FLOAT, GL_FALSE, 0, 0);


}


void ClothComponent::drawCloth()
{
	glBindVertexArray(clothVAO);
		int sizeInBytes = 0;
		// particles as vertices
		glBindBuffer(GL_ARRAY_BUFFER, clothVBO_V);
		sizeInBytes = (this->vertexNumber * 3) * sizeof(float);
		glBufferData(GL_ARRAY_BUFFER, sizeInBytes, &this->vertexData[0], GL_STATIC_DRAW);
		glEnableVertexAttribArray(positionAttributeIndex);
		glVertexAttribPointer(positionAttributeIndex, 3, GL_FLOAT, GL_FALSE, 0, 0);

		// normals at each particle
		glBindBuffer(GL_ARRAY_BUFFER, clothVBO_N);
		sizeInBytes = (this->vertexNumber * 3) * sizeof(float);
		glBufferData(GL_ARRAY_BUFFER, sizeInBytes, &this->normalData[0], GL_STATIC_DRAW);
		glEnableVertexAttribArray(normalAttributeIndex);
		glVertexAttribPointer(normalAttributeIndex, 3, GL_FLOAT, GL_FALSE, 0, 0);
	glBindVertexArray(0);

	GLObject* glo = GetOwner()->GetGLObject();

	shader->UseProgram();
	glBindVertexArray(clothVAO);

		glEnable(GL_DEPTH_TEST);

		shader->ChooseTextureUnit(0, "textureSampler");
		texture->Use();

		int IsCloth = 1;
		GLint IsClothLoc = glGetUniformLocation(shader->GetProgramID(), "IsCloth");
		glUniform1i(IsClothLoc, IsCloth);

		Camera3D* currentCamera = renderManager->GetRender3D()->CurrentCamera;
		GLint proj = glGetUniformLocation(shader->GetProgramID(), "Projection");
		glUniformMatrix4fv(proj, 1, GL_FALSE, &currentCamera->Projection[0][0]);

		GLint view = glGetUniformLocation(shader->GetProgramID(), "View");
		glUniformMatrix4fv(view, 1, GL_FALSE, &currentCamera->View[0][0]);


		glm::mat4 S;
		S = glm::scale(glm::mat4(1.0f), glm::vec3(0.2f, 0.2f, 0.2f)*8.0f);
		GLint locc = glGetUniformLocation(shader->GetProgramID(), "ClothS");
		glUniformMatrix4fv(locc, 1, GL_FALSE, &S[0][0]);

		if (uiManager->RenderDebugMode)
		{
			glLineWidth(1.0f);
			int loc = glGetUniformLocation(shader->GetProgramID(), "DebugMode");
			glUniform1i(loc, 1);
			glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
			glDrawArrays(GL_TRIANGLES, 0, vertexNumber);

			glLineWidth(1.0f);
			loc = glGetUniformLocation(shader->GetProgramID(), "DebugMode");
			glUniform1i(loc, 0);
			glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
			glDrawArrays(GL_TRIANGLES, 0, vertexNumber);
		}
		else
		{
			glDrawArrays(GL_TRIANGLES, 0, vertexNumber);
		}
		
		

		glDisable(GL_DEPTH_TEST);

		glBindTexture(GL_TEXTURE_2D, 0);

		IsCloth = 0;
		IsClothLoc = glGetUniformLocation(shader->GetProgramID(), "IsCloth");
		glUniform1i(IsClothLoc, IsCloth);

	glBindVertexArray(0);
}