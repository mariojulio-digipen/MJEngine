// Autogenerated by MJEngine automation tools
// Edition author: mzaldivar

#include "BodyComponent.h"
#include "GameObject.h"
#include "TransformComponent.h"
#include "PhysicsManager.h"
#include "AABB.h"
#include "Circle.h"
#include "FrameRateController.h"
#include "ResourceManager.h"


#include <algorithm>
#include <glew.h>

extern PhysicsManager* physicsManager;
extern FrameRateController* frameRateController;
extern ResourceManager* resourceManager;


BodyComponent::BodyComponent()
{
	
}


BodyComponent::~BodyComponent()
{
}

bool BodyComponent::Init()
{
	
	Transform = GetOwner()->FindComponent<TransformComponent>();
	if (Transform)
	{
		Position = Transform->GetPosition();
		Rotation = Transform->GetRotation();
		return true;
	}
		
	return false;
}

void BodyComponent::Update()
{
	// TODO
	if (BodyShape->Type == Shape::ShapeType::RECTANGLE)
	{
		AABB* aabb = static_cast<AABB*>(BodyShape);
		TransformComponent* dqTrans = debugquad->FindComponent<TransformComponent>();
		dqTrans->SetPosition(Transform->GetPosition());
		dqTrans->SetScale(glm::vec3(abs(aabb->Right), abs(aabb->Top), 0.0f));
	}
	if (BodyShape->Type == Shape::ShapeType::CIRCLE)
	{
		Circle* circle = static_cast<Circle*>(BodyShape);
		TransformComponent* dqTrans = debugquad->FindComponent<TransformComponent>();
		dqTrans->SetPosition(Transform->GetPosition());
		dqTrans->SetScale(glm::vec3(abs(circle->Radius), abs(circle->Radius), 0.0f));
	}
}

void BodyComponent::Integrate()
{
	// get the current transform values
	Position = Transform->GetPosition();
	Rotation = Transform->GetRotation();

	// numerical integration
	Force.y += physicsManager->GRAVITY*Mass;
	Accelaration = Force * InverseMass;
	Velocity += Accelaration;// * frameRateController->DeltaTime;
	Rotation += AngularVelocity;// * frameRateController->DeltaTime;
	Position += Velocity;// * frameRateController->DeltaTime;

	// reset force
	Force = glm::vec3(0.0f, 0.0f, 0.0f);

	// update the transform
	Transform->SetPosition(Position);
	Transform->SetRotation(Rotation);

	/*std::string name = GetOwner()->GetName();
	std::cout << "Transform of " << name;
	printf(": (%f, %f, %f)\n", Transform->GetPosition().x, Transform->GetPosition().y, Transform->GetPosition().z);*/

	
}

void BodyComponent::Serialize(std::istringstream* objcontentStream)
{
	std::string line;
	std::getline((*objcontentStream), line);

	std::istringstream lineStream(line.c_str());
	std::string word;

	while ((*objcontentStream) >> word)
	{
		if (word == "#")
		{
			std::getline((*objcontentStream), line);
			continue;
		}
		if (word == "aabb")
		{
			std::getline((*objcontentStream), line);
			BodyShape = new AABB;
			AABB* aabb = static_cast<AABB*>(BodyShape);
			aabb->OwnerBody = this;
			sscanf_s(line.c_str(), "%f %f %f %f", &aabb->Left, &aabb->Right, &aabb->Top, &aabb->Bottom);
			continue;
		}
		if (word == "circle")
		{
			std::getline((*objcontentStream), line);
			BodyShape = new Circle;
			Circle* circle = static_cast<Circle*>(BodyShape);
			circle->OwnerBody = this;
			circle->Radius = std::stof(line);
			continue;
		}
		if (word == "mass")
		{
			std::getline((*objcontentStream), line);
			Mass = std::stof(line);
		}
		if (word == "invmass")
		{
			std::getline((*objcontentStream), line);
			InverseMass = std::stof(line);
		}

	}
}

void BodyComponent::CompleteExtraSetup()
{
	physicsManager->ManageThisGameObject(GetOwner());


	if (BodyShape->Type == Shape::ShapeType::RECTANGLE)
		debugquad = resourceManager->CreateOneGameObject("DebugQuad");
	if (BodyShape->Type == Shape::ShapeType::CIRCLE)
		debugquad = resourceManager->CreateOneGameObject("DebugCircle");
	

}

void BodyComponent::Destroy()
{

}

void BodyComponent::updateTransform()
{
	if (Transform)
	{
		Transform->SetPosition(Position);
		Transform->SetRotation(Rotation);
	}
}
