// KeyFrameAnimationComponent.CPP
// Implementation autogenerated by MJEngine automation tools
// WARNING: Do not modify autogenerated comments, automation 
// tools depend on them.

// Edition author: mzaldivar

#include "KeyFrameAnimationComponent.h"
#include "MoveAlongPathComponent.h"
#include "Spline.h"
#include "GameObject.h"
#include "FrameRateController.h"
#include "Transform.h"
#include "UIManager.h"
#include "Event.h"

#include <sstream>
#include <algorithm>

extern FrameRateController* frameRateController;
extern UIManager* uiManager;

KeyFrameAnimationComponent::KeyFrameAnimationComponent()
{
	startCount = true;
}


KeyFrameAnimationComponent::~KeyFrameAnimationComponent()
{
}


bool KeyFrameAnimationComponent::Init()
{
	// TODO - Implement initializations here
	// This function runs once when object manager
	// load objects, before serialization
	ownerGlo = GetOwner()->GetGLObject();
	delta = 0;
	return true;
}

// In order to control the skidding and sliding, 
// this component needs to retrieve a reference to 
// the spline, which is easy to do since Spline is a
// property of MoveAlongPathComponent, and both this
// and KeyFrameAnimationComponent are components of 
// the root bone of the skeleton. This means, that from
// here, we can find the MoveAlongPathComponent and
// query the spline reference, and with that, we can
// get the current time and velocity to generate a 
// factor that will influence the animation cycle 
// velocity.
void KeyFrameAnimationComponent::Update()
{

	// retrieve velocity and distance covered (root bone only)

	// Hardcoded for now. Let's paramaterize this later...
	//if (ownerGlo->Name == "LeftArm")
		//return;


	//if (ownerGlo->Name == "Hips")
	// In the current animation, there is always only one root
	if (ownerGlo->Bonetype == BONE_TYPE::ROOT)
	{
		moveComponent =
			GetOwner()->FindComponent<MoveAlongPathComponent>();
	}
	else
	{
		// Children inherit parent's path. 
		// Remember, only the root bone has a path to move along.
		KeyFrameAnimationComponent* parentKeyFrameAnimComp =
			GetOwner()->GetParent()->FindComponent<KeyFrameAnimationComponent>();
		moveComponent = parentKeyFrameAnimComp->GetMoveComponent();
	}

	// child bones do not have the MoveAlongPathComponent component attached to them
	// so, in that case, nothing to do.
	if (!moveComponent)
		return;


	float delta = frameRateController->DeltaTime;
	if (t == 0.0000)
		startSeconds = frameRateController->GetSeconds();

	Uint32 velo = uiManager->AnimationSpeed;
	if (!uiManager->Playing)
		return;
	
	// if character is moving along the space curve, 
	// then apply the n factor
	// otherwise, compute regular animation cycle
	if (!moveComponent->GetCurvePath())
		return;

	if (moveComponent->GetCurvePath()->IsActive())
		t += n*velo; // for movement along the path
	else
	{
		t += 0.0000;//0.0003*velo; // for static animation

		ownerGlo->Transform->VQS_ModelToWorldForBone = ownerGlo->KeyFramesData[0].vqs;
		return;
	}
		

	if (t >= 1.0000)
	{
		//debug.clear();
		t = 0.0000;
		//debugFramesNumber = 0;
		currentSeconds = 
			frameRateController->GetSeconds() - startSeconds;
		
		int a = 0;
		a++;
	}

	if(currentSeconds > 0)
		cyclesPerSecond = 
			1 / static_cast<float>(currentSeconds);
	
	uiManager->AnimPerSec = cyclesPerSecond;


	std::vector<GLObjectAnimKeyFrames>::iterator begin = 
		ownerGlo->KeyFramesData.begin();
	std::vector<GLObjectAnimKeyFrames>::iterator end =
		ownerGlo->KeyFramesData.end();

	auto ptr = std::upper_bound(begin, end, t, compare_t());
	auto ptr_prv = ptr - 1;

	VQS keyframe_0 = ptr_prv->vqs;
	long double time_0 = ptr_prv->time;
	VQS keyframe_1 = ptr->vqs;
	long double time_1 = ptr->time;
	
	long double a = (t - time_0) / (time_1 - time_0);
	float u = static_cast<float>(a);

	VQS newvqs_u = VQS::Interpolate(keyframe_0, keyframe_1, u);
	ownerGlo->Transform->VQS_ModelToWorldForBone = newvqs_u;




	if (moveComponent)
	{
		Spline* spl = moveComponent->GetCurvePath();
		if (spl)
		{
			float time =
				static_cast<float>(moveComponent->GetCurvePath()->GetCurrentTime());
			v_t =
				moveComponent->GetCurvePath()->VelocityTime(time, delta, 0.05, 0.35);

			P = moveComponent->GetCurvePath()->DistanceTime(time, delta, 0.05, 0.35);
			P = P * 300;
			
			if (P > 0)
			{	// I calculate the 400 constant just by eye, using the method professor
				// gave us in class. Then, divide the current velocity by this constant
				// and store in n, which will be multiplied by the actual
				// time step. (See the true condition in line #75)
				n = (v_t / 400)*motionCycleFlag;;// *motionCycleFlag;
			}
				
		}


	}




	


	




	//GLObjectAnimKeyFrames keyframe;
	//keyframe.time = u;
	//keyframe.vqs = newvqs_u;
	//debug.push_back(keyframe);




	//return;
	// TODO - Implement all the updates here
	// This function is executed once everyframe
	/*Uint32 frame_number_now = frameRateController->GetFrameNumber();
	if (velo != prevVelo)
	{
		frameRateController->SetFrameAtLevelStart(frame_number_now);
	}
	
	Uint32 frame_number_atLevelStart = 
		frameRateController->GetFrameAtLevelStart();
	Uint32 delta = frame_number_now - frame_number_atLevelStart;*/


	
	/*if (!uiManager->Playing)
		return;

	Uint32 localDelta = 0;

	if (velo != prevVelo)
		delta = 0;
	
	localDelta = delta++;
	
	if (localDelta < (ownerGlo->KeyFramesData.size()-1) / velo)
	{
		prevDelta = delta;
		
		localDelta = (delta * velo);
		prevVelo = velo;
		

		ownerGlo->Transform->VQS_ModelToWorldForBone =
			ownerGlo->KeyFramesData[localDelta].vqs;
		

	}
	else
	{
		delta = 0;
	}*/
		
}


void KeyFrameAnimationComponent::Destroy()
{
	// TODO - Optional, use to release memory
	// This function is called by the user.
}


void KeyFrameAnimationComponent::CompleteExtraSetup()
{
	// TODO - Implement any setup that needs to be executed
	// after the owner gameobject already exists.
	t = 0.0000;
}


void KeyFrameAnimationComponent::HandleEvent(const Event* const evt)
{
	// TODO - Implement reactions to different events
	const StartMovingAlongPath* moveAlong =
		dynamic_cast<const StartMovingAlongPath*>(evt);
	if (moveAlong != NULL)
	{
		motionCycleFlag = 1.0000;
	}

	const StopMovingAlongPath* stopAlong =
		dynamic_cast<const StopMovingAlongPath*>(evt);
	if (stopAlong != NULL)
	{
		//t = 0.0000;
		//n = 0.0000;
		motionCycleFlag = 0.0000;
	}

}
