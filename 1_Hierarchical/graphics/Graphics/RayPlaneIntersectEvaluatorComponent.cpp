// RayPlaneIntersectEvaluatorComponent.CPP
// Implementation autogenerated by MJEngine automation tools
// WARNING: Do not modify autogenerated comments, automation 
// tools depend on them.

// Edition author: mzaldivar

#include "RayPlaneIntersectEvaluatorComponent.h"
#include "RenderManager.h"
#include "Render3D.h"
#include "GameObject.h"
#include "TransformComponent.h"
#include "ResourceManager.h"
#include "UIManager.h"
#include "FollowMeComponent.h"
#include "Event.h"
#include "EventManager.h"

#include <sstream>
#include <glm.hpp>

extern RenderManager* renderManager;
extern ResourceManager* resourceManager;
extern UIManager* uiManager;
extern EventManager* eventManager;

void createControlSphere(float* D, glm::vec3* firstPoint, glm::vec3* intersectionPoint);

RayPlaneIntersectEvaluatorComponent::RayPlaneIntersectEvaluatorComponent()
{
}


RayPlaneIntersectEvaluatorComponent::~RayPlaneIntersectEvaluatorComponent()
{
}


bool RayPlaneIntersectEvaluatorComponent::Init()
{
	// TODO - Implement initializations here
	// This function runs once when object manager
	// load objects, before serialization

	currentCamera = renderManager->GetRender3D()->CurrentCamera;
	trans = GetOwner()->FindComponent<TransformComponent>();
	modelRootTrans = resourceManager->GetGameObjectByName("Hips")
		->FindComponent<TransformComponent>();

	// Get a reference of the root bone from boy skeleton


	return true;
}


void RayPlaneIntersectEvaluatorComponent::Update()
{
	// TODO - Implement all the updates here
	// This function is executed once everyframe
	if (intersectionPoints.size() >= 8)
		return;

	if (!currentCamera->IsRayCaster())
		return;


	if (!currentCamera->CastedRay() || currentCamera->StopCasting())
		return;



	glm::vec3 rayDirection = currentCamera->CamRayDirection;
	glm::vec3 camPos = currentCamera->Position;

	// Calculate the normal of the current plane of owner object.
	// The normal of the plane will be the cross product of two
	// arbitrary vector on the plane
	glm::vec3 planeNormal;
	glm::vec3 vector_1;
	glm::vec3 vector_2;

	// I will find atwo vector based on the radius
	// which in turn is based on the scale, including the direction.
	// That's why it does not matter which scale I choose, x or z.
	Quaternion rotator_1;
	Quaternion rotator_2;
	glm::vec3 to_rotate;
	VQS VQS_Transform;
	VQS VQS_Transform2;

	float radius = trans->GetScale().x;
	to_rotate = glm::vec3(radius, 0, 0.0f);

	// angles to get vectors from the plane
	float angle = glm::radians(45.0f);
	float angle2 = glm::radians(180.0f);
	
	rotator_1 = Quaternion::QuatFromAngles(glm::vec3(trans->GetRotation().x, angle, trans->GetRotation().z));
	VQS_Transform = VQS(glm::vec3(0.0f), rotator_1, 1.0f);
	vector_1 = VQS_Transform * to_rotate;


	rotator_2 = Quaternion::QuatFromAngles(glm::vec3(trans->GetRotation().x, angle2 , trans->GetRotation().z));
	VQS_Transform2 = VQS(glm::vec3(0.0f), rotator_2, 1.0f);
	vector_2 = VQS_Transform2 * to_rotate;

	planeNormal = glm::cross(vector_1, vector_2);
	planeNormal = glm::normalize(planeNormal);

	// test if normal is actually perpendicular to plane
	float cosine_test = glm::dot(planeNormal, vector_1);
	float arcos = glm::degrees(glm::acos(cosine_test));
	// end test

	rayDirection = glm::normalize(rayDirection);

	float dot_Cam_Normal = glm::dot(camPos, planeNormal);
	float dot_RayDir_Normal = glm::dot(rayDirection, planeNormal);
	float D = trans->GetPosition().y + radius * 0.5f;
	float t = -(dot_Cam_Normal + D) / dot_RayDir_Normal;

	glm::vec3 intersectionPoint = camPos + t * rayDirection;
	intersectionPoints.push_back(intersectionPoint);
	if (intersectionPoints.size() == 1)
	{
		glm::vec3 pos = glm::vec3(modelRootTrans->GetPosition().x, intersectionPoint.y, modelRootTrans->GetPosition().z);
		intersectionPoints.insert(intersectionPoints.begin(), pos);
		//createControlSphere(&D, &pos);
	}

	// activate this code through the UI, 
	// i.e. put a checkbox for project2, 
	// other for project 3.
	// for now, default behavior is project 3
	glm::vec3 newPoint;
	if (intersectionPoints.size() == 3)
	{
		intersectionPoints.clear();
		newPoint = glm::vec3(
			modelRootTrans->GetPosition().x, 
			intersectionPoint.y, 
			modelRootTrans->GetPosition().z);
		intersectionPoints.push_back(newPoint);
		intersectionPoints.push_back(intersectionPoint);

		DeleteControlPoints* deleteCPEvt =
			eventManager->GenerateEvent<DeleteControlPoints>();
		eventManager->BroadCastEvent(deleteCPEvt);

	}
		
	//std::cout << "Estas creando intersection points!" << std::endl;
	createControlSphere(&D, &newPoint, &intersectionPoint);
	
	


	// to restrict only one line, need to be conditioned to something:

	

	return;


	
}


void RayPlaneIntersectEvaluatorComponent::HandleEvent(const Event* const evt)
{
	// TODO - Implement reactions to different events
}

void RayPlaneIntersectEvaluatorComponent::Destroy()
{
	// TODO - Optional, use to release memory
	// This function is called by the user.
}


void RayPlaneIntersectEvaluatorComponent::DeleteIntersectionPoints()
{
	if (intersectionPoints.size() > 0) intersectionPoints.clear();
}


void createControlSphere(float* D, glm::vec3* firstPoint, glm::vec3* intersectionPoint)
{
	// spawn a new  ball at intersection point, 
	// only for better visual debug
	GameObject* newsphere = NULL;
	std::map<std::string, GameObject*> tmpMap = resourceManager->Get3DGameObjectsMap();
	std::map<std::string, GameObject*>::iterator go3DIt = tmpMap.find("Target"); //Ball
	if (go3DIt == tmpMap.end())
		return;
	newsphere = resourceManager->SpawnNewGameObjectFromArchetype("Target"); //Ball
	newsphere->IsAlive = true;
	newsphere->IsDeferred = false;
	//newsphere->SetNewName("ActualTarget");
	
	
	
	FollowMeComponent* comp = 
		resourceManager->AttachComponent<FollowMeComponent>(newsphere);
	comp->Init();

	intersectionPoint->y = (*D);

	glm::vec3 point = (*intersectionPoint);
	glm::vec3 modelLocation = (*firstPoint);
	glm::vec3 pathDirection = point - modelLocation;
	
	
	glm::vec3 pathDirNormalized = glm::normalize(pathDirection);
	glm::vec3 globalX = glm::vec3(1.0f, 0.0f, 0.0f);
	float l1 = glm::length(pathDirNormalized);
	float l2 = glm::length(globalX);

	float arcosine = 0.0f;
	float angle = 0.0f;
	float cosine = 0.0f;
	float sine = 0.0f;

	cosine = glm::dot(pathDirNormalized, globalX);
	sine = pathDirNormalized.x * globalX.z - pathDirNormalized.z * globalX.x;

	angle = -glm::degrees(atan2f(sine, cosine));


	float pointZ = (glm::length(pathDirection) + 10.0f) * glm::sin(glm::radians(angle));// + 3.0f;
	float pointX = (glm::length(pathDirection) + 10.0f) * glm::cos(glm::radians(angle));// + 3.0f;

	glm::vec3 finalVec = modelLocation + glm::vec3(pointX, 0.0f, pointZ);
	TransformComponent* ballTrans = newsphere->FindComponent<TransformComponent>();
	ballTrans->SetPosition(finalVec + glm::vec3(0.0f, 8.2f, 0.0f));// + 0.2f
	//ballTrans->SetPosition(finalVec + glm::vec3(0.0f, 0.2f, 0.0f));// + 0.2f
	ballTrans->SetScale(glm::vec3(0.4f, 0.4f, 0.4f) * 3.0f);


	//TransformComponent* ballTrans = newsphere->FindComponent<TransformComponent>();
	//ballTrans->SetPosition((*intersectionPoint) + glm::vec3(0.0f, 0.2f, 0.0f));// + 0.2f
	//ballTrans->SetScale(glm::vec3(0.4f, 0.4f, 0.4f) * 5.0f);


	CreateControlPoint* createCPEvt =
		eventManager->GenerateEvent<CreateControlPoint>();
	createCPEvt->SetPoint(newsphere);
	eventManager->BroadCastEvent(createCPEvt);
}