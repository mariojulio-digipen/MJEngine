// ParticleVortexComponent.CPP
// Implementation autogenerated by MJEngine automation tools
// WARNING: Do not modify autogenerated comments, automation 
// tools depend on them.

// Edition author: mzaldivar

#include "ParticleVortexComponent.h"
#include "ParticleSystem.h"
#include "MeshParticle.h"
#include "GameObject.h"
#include "TransformComponent.h"
#include "Render3D.h"
#include "RenderManager.h"
#include "LightPointComponent.h"
#include "ResourceManager.h"
#include "Lighter.h"
#include "FrameRateController.h"
#include "UIManager.h"

#include <sstream>
#include <ctime>

extern RenderManager* renderManager;
extern ResourceManager* resourceManager; 
extern Shader* meshParticleShader;
extern Shader* shader;
extern FrameRateController* frameRateController;
extern UIManager* uiManager;

ParticleVortexComponent::ParticleVortexComponent() : currentParticles(0), lit(true)
{
}


ParticleVortexComponent::~ParticleVortexComponent()
{
}


bool ParticleVortexComponent::Init()
{
	// TODO - Implement initializations here
	// This function runs once when object manager
	// load objects, before serialization
	uiManager->VortexActive = GetOwner()->IsAlive;
	trans = GetOwner()->FindComponent<TransformComponent>();

	return true;
}


void ParticleVortexComponent::Update()
{
	// TODO - Implement all the updates here
	// This function is executed once everyframe

	if (!uiManager->VortexActive)
		return;
	
	this->h = 0.01f;
	this->K = uiManager->VortexRotationRate;
	this->T = uiManager->VortexTightnes;//1.50f;

	// update the model matrix
	// for each particle
	std::vector<glm::mat4> models;
	for (int i = 0; i < currentParticles; i++)
	{
		MeshParticle* particle = particlesContainer[i];
		glm::mat4 newModelMatrix;
		
		// actual vortex operation
		glm::vec3 xt = particle->GetLocation();			// x(t) previous position
		
		
		float angle = computeRotationAngle(xt);			// rotation angle
		glm::mat3 R0u = computeRotationMatrix(angle);	// rotation matrix R0u

		glm::vec3 xth = vo + R0u*(xt - vo);				// x(t + h) new position
		

		// make the translation matrix
		glm::mat4 translate = glm::translate(glm::mat4(1.0f), xth);

		// and that will be the model matrix 
		// (rotation and scale are implicit)

		glm::mat4 prevModelMatrix = particle->GetModelMatrix();
		newModelMatrix = prevModelMatrix * translate;
		models.push_back(newModelMatrix);

		// update previous location with current
		particle->SetLocation(xth);


		
	}

	particleSystem->SetModelMatrices(&models[0]);
	

	
	GLint currentProgramId;
	glGetIntegerv(GL_CURRENT_PROGRAM, &currentProgramId);

	shader->UnUseProgram();
	
	
	
	int shaderUsed = meshParticleShader->GetProgramID();//particleSystem->GetShaderUsed();
	meshParticleShader->UseProgram(); // particle system uses mesh shader
	
	// updates lighting
	Lighter lighter;
	lighter.ProcessLights(shaderUsed, light);

	
	particleSystem->Draw();


	shader->UseProgram();
}


void ParticleVortexComponent::Destroy()
{
	// TODO - Optional, use to release memory
	// This function is called by the user.

	for (int i = 0; i < currentParticles; i++)
		delete particlesContainer[i];
	particlesContainer.clear();

	delete particleSystem;
}


void ParticleVortexComponent::Serialize(std::istringstream* objcontentStream)
{
	std::string line;
	std::getline((*objcontentStream), line);

	std::istringstream lineStream(line.c_str());
	std::string word;

	while ((*objcontentStream) >> word)
	{
		if (word == "#")
		{
			std::getline((*objcontentStream), line);
			continue;
		}

		if (word == "amount")
		{
			std::getline((*objcontentStream), line);
			currentParticles = static_cast<int>(atoi(line.c_str()));
		}
		
		// TODO - Implement more if statements according to the file format
		// This function runs right after the Init function
		if (word == "texture")
		{
			std::getline((*objcontentStream), line);
			line.erase(line.begin());
			textureImage = line;
		}
		
		
	}
}


void ParticleVortexComponent::CompleteExtraSetup()
{
	// TODO - Implement any setup that needs to be executed
	// after the owner gameobject already exists.

	
}


void ParticleVortexComponent::HandleEvent(const Event* const evt)
{
	// TODO - Implement reactions to different events
}

void ParticleVortexComponent::Start()
{
	particleSystem = new ParticleSystem;
	particleSystem->SetMaxParticles(currentParticles); // constant
	particleSystem->SetCurrentParticles(currentParticles); // will manipulated through the uimanager
	particleSystem->SetTextureImage(textureImage.c_str());
	particleSystem->Init();

	for (int i = 0; i < currentParticles; i++)
	{
		MeshParticle* particle = new MeshParticle;
		particlesContainer.push_back(particle);
	}

	GameObject* obj = resourceManager->GetGameObjectByName("Sphere");
	light = obj->FindComponent<LightPointComponent>();

	
	srand(static_cast <unsigned> (time(0)));
	/*for (int i = 0; i < currentParticles; i++)
	{
		MeshParticle* particle = particlesContainer[i];
		glm::vec3 location = trans->GetPosition();
		float rotation = 0.0f;
		float scale = (rand() % 40) / 100.0f + 0.05f;

		particle->SetLocation(location);
		particle->SetRotation(rotation);
		particle->SetScale(glm::vec3(scale));


	}*/

	// create a random value for the initial condition of x(t)
	float radius = 5.0;
	float offset = 1.5f;
	for (int i = 0; i < currentParticles; i++)
	{
		MeshParticle* particle = particlesContainer[i];

		GLfloat angle = (GLfloat)i / (GLfloat)currentParticles * 360.0f;
		GLfloat displacement = (rand() % (GLint)(2 * offset * 100)) / 100.0f - offset;
		float x = sin(angle) * radius + displacement;
		displacement = (rand() % (GLint)(16 * offset * 100)) / 100.0f - offset;
		float y = displacement * 0.4f;
		displacement = (rand() % (GLint)(2 * offset * 100)) / 100.0f - offset;
		float z = cos(angle) * radius + displacement;
		glm::vec3 location = glm::vec3(x, y, z);
		location += trans->GetPosition();
		particle->SetLocation(location);

		angle = 0.0f;//static_cast<float>(rand() % 360); //static_cast<float>(rand() % 360);
		particle->SetRotation(angle);

		float scale = (rand() % 200) / 100.0f + 0.05f;
		particle->SetScale(glm::vec3(scale));

	}

}


glm::mat3 ParticleVortexComponent::computeRotationMatrix(float angle)
{
	return particleSystem->SpiralRotationMatrix(angle, u);

}


float ParticleVortexComponent::computeRotationAngle(glm::vec3 xt)
{
	return particleSystem->VortexRotationAngle(xt, vo, u, K, T, h);
}