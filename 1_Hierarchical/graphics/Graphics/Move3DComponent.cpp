// Move3DComponent.CPP
// Implementation autogenerated by MJEngine automation tools
// WARNING: Do not modify autogenerated comments, automation 
// tools depend on them.

// Edition author: mzaldivar

#include "Move3DComponent.h"
#include "InputManager.h"
#include "Event.h"
#include "EventManager.h"
#include "TransformComponent.h"
#include "FrameRateController.h"

#include <gtc\matrix_transform.hpp>
#include <gtx\matrix_decompose.hpp>
#include <gtc\type_ptr.hpp>
#include <gtx\euler_angles.hpp>
#include <glm.hpp>
#include <sstream>

extern InputManager* inputManager;
extern EventManager* eventManager;
extern FrameRateController* frameRateController;

Move3DComponent::Move3DComponent() : move(false)
{
}


Move3DComponent::~Move3DComponent()
{
}


bool Move3DComponent::Init()
{
	// TODO - Implement initializations here
	// This function runs once when object manager
	// load objects, before serialization
	transform = GetOwner()->FindComponent<TransformComponent>();
	if (transform)
		return true;
	return false;
}


void Move3DComponent::Update()
{
	// TODO - Implement all the updates here
	// This function is executed once everyframe
	float velo = 0.3f;
	float delta = 0.3f;



	if (inputManager->IsKeyDown(SDL_SCANCODE_KP_8))
	{
		glm::vec3 np = glm::vec3(transform->GetPosition().x, transform->GetPosition().y + velo, transform->GetPosition().z);
		transform->SetPosition(np);
		glm::mat4 T = glm::translate(glm::mat4(1.0f), transform->GetPosition());
		GetOwner()->GetGLObject()->Transform->TranslateForBoneMatrix = T;

		glm::vec3 VQS_T = transform->GetPosition();
		GetOwner()->GetGLObject()->Transform->VQS_TranslatorForBone = VQS_T;
		move = true;
	}
	if (inputManager->IsKeyReleased(SDL_SCANCODE_KP_8))
	{
		move = false;
	}

	if (inputManager->IsKeyDown(SDL_SCANCODE_KP_0))
	{
		glm::vec3 np = glm::vec3(transform->GetPosition().x, transform->GetPosition().y - velo, transform->GetPosition().z);
		transform->SetPosition(np);
		glm::mat4 T = glm::translate(glm::mat4(1.0f), transform->GetPosition());
		GetOwner()->GetGLObject()->Transform->TranslateForBoneMatrix = T;

		glm::vec3 VQS_T = transform->GetPosition();
		GetOwner()->GetGLObject()->Transform->VQS_TranslatorForBone = VQS_T;
		move = true;
	}
	if (inputManager->IsKeyReleased(SDL_SCANCODE_KP_0))
	{
		move = false;
	}

	if (inputManager->IsKeyDown(SDL_SCANCODE_KP_5))
	{
		glm::vec3 np = glm::vec3(transform->GetPosition().x, transform->GetPosition().y, transform->GetPosition().z - velo);
		transform->SetPosition(np);
		glm::mat4 T = glm::translate(glm::mat4(1.0f), transform->GetPosition());
		GetOwner()->GetGLObject()->Transform->TranslateForBoneMatrix = T;

		glm::vec3 VQS_T = transform->GetPosition();
		GetOwner()->GetGLObject()->Transform->VQS_TranslatorForBone = VQS_T;
		move = true;
	}
	if (inputManager->IsKeyReleased(SDL_SCANCODE_KP_5))
	{
		move = false;
	}

	if (inputManager->IsKeyDown(SDL_SCANCODE_KP_2))
	{
		glm::vec3 np = glm::vec3(transform->GetPosition().x, transform->GetPosition().y, transform->GetPosition().z + velo);
		transform->SetPosition(np);
		glm::mat4 T = glm::translate(glm::mat4(1.0f), transform->GetPosition());
		GetOwner()->GetGLObject()->Transform->TranslateForBoneMatrix = T;

		glm::vec3 VQS_T = transform->GetPosition();
		GetOwner()->GetGLObject()->Transform->VQS_TranslatorForBone = VQS_T;
		move = true;
	}
	if (inputManager->IsKeyReleased(SDL_SCANCODE_KP_2))
	{
		move = false;
	}

	if (inputManager->IsKeyDown(SDL_SCANCODE_KP_1))
	{
		moveX--;
		transform->SetPosition(
			glm::vec3(
				transform->GetPosition().x - velo, transform->GetPosition().y, transform->GetPosition().z));
		glm::vec3 axis_converted = glm::vec3(transform->GetPosition().x, transform->GetPosition().y, transform->GetPosition().z);
		glm::mat4 T = glm::translate(glm::mat4(1.0f), axis_converted);
		GetOwner()->GetGLObject()->Transform->TranslateForBoneMatrix = T;

		// send updated vqs translator
		glm::vec3 VQS_T = transform->GetPosition();
		GetOwner()->GetGLObject()->Transform->VQS_TranslatorForBone = VQS_T;
		move = true;
	}
	if (inputManager->IsKeyReleased(SDL_SCANCODE_KP_1))
	{
		move = false;
	}

	if (inputManager->IsKeyDown(SDL_SCANCODE_KP_3))
	{
		moveX++;
		transform->SetPosition(
			glm::vec3(
				transform->GetPosition().x + velo, transform->GetPosition().y, transform->GetPosition().z));
		glm::vec3 axis_converted = glm::vec3(transform->GetPosition().x, transform->GetPosition().y, transform->GetPosition().z);
		glm::mat4 T = glm::translate(glm::mat4(1.0f), axis_converted);
		GetOwner()->GetGLObject()->Transform->TranslateForBoneMatrix = T;

		glm::vec3 VQS_T = transform->GetPosition();
		GetOwner()->GetGLObject()->Transform->VQS_TranslatorForBone = VQS_T;
		move = true;
	}
	if (inputManager->IsKeyReleased(SDL_SCANCODE_KP_3))
	{
		move = false;
	}

	

	if (move)
	{
		IKCCDResetIterations* resetCCDIters =
			eventManager->GenerateEvent<IKCCDResetIterations>();
		eventManager->BroadCastEvent(resetCCDIters);
		std::cout << "Avisar a followme que reinicie la cuenta!" << std::endl;
	}

	


	
}


void Move3DComponent::Destroy()
{
	// TODO - Optional, use to release memory
	// This function is called by the user.
}


