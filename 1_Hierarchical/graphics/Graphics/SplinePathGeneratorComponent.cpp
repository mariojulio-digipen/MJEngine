// SplinePathGeneratorComponent.CPP
// Implementation autogenerated by MJEngine automation tools
// WARNING: Do not modify autogenerated comments, automation 
// tools depend on them.

// Edition author: mzaldivar

#include "SplinePathGeneratorComponent.h"
#include "Spline.h"
#include "RayPlaneIntersectEvaluatorComponent.h"
#include "GameObject.h"
#include "GLObject.h"
#include "TransformComponent.h"
#include "ResourceManager.h"
#include "UIManager.h"
#include "EventManager.h"
#include "FrameRateController.h"

#include <sstream>
#include <vector>
#include <glm.hpp>



extern ResourceManager* resourceManager;
extern UIManager* uiManager;
extern EventManager* eventManager;
extern FrameRateController* frameRateController;

void clearCpGOs(std::vector<GameObject*>* cpGos);

SplinePathGeneratorComponent::SplinePathGeneratorComponent() : 
	pathExists(false), msgSent(false), spline(new Spline)
{
}


SplinePathGeneratorComponent::~SplinePathGeneratorComponent()
{
	delete spline;
}


bool SplinePathGeneratorComponent::Init()
{
	// TODO - Implement initializations here
	// This function runs once when object manager
	// load objects, before serialization
	rayCaster = 
		GetOwner()->FindComponent<RayPlaneIntersectEvaluatorComponent>();
	
	
	return true;
}


void SplinePathGeneratorComponent::Update()
{
	// TODO - Implement all the updates here
	// This function is executed once everyframe

	//float planeY = GetOwner()->FindComponent<TransformComponent>()->GetPosition().y;

	
	if (uiManager->SplineReset)
	{
		eraseCurve();
		spline->ClearCurvePoints();
		spline->ResetTime();
		spline->Deactivate();
		rayCaster->DeleteIntersectionPoints();
		uiManager->SplineReset = false;
		pathExists = false;
		msgSent = false;
		
		clearCpGOs(&cpGOs);
		//for (size_t i = 0; i < cpGOs.size(); i++)
		//{
		//	cpGOs[i]->NeedsDeletion = true; // Need to implement memory management soon!!
		//	cpGOs[i]->IsAlive = false;
		//}
		//cpGOs.clear();

		StopMovingAlongPath* stopAlongEvent =
			eventManager->GenerateEvent<StopMovingAlongPath>();
		eventManager->BroadCastEvent(stopAlongEvent);
	}

	
	std::vector<glm::vec3>* controlPoints;
	controlPoints = rayCaster->GetIntersectionPoints();
	if (controlPoints->size() == 0)
		return;

	std::vector<glm::vec3> curvePoints =
		spline->CubicSpline(controlPoints);
	std::vector<glm::vec3>::iterator cpIt = curvePoints.begin();
	if (curvePoints.size() == 0)
		return;
	else
		spline->Activate();
	
	if (!uiManager->SplineHidden)
	{
		while (cpIt != curvePoints.end() - 1)
		{
			GetOwner()->GetGLObject()->DrawDot((*cpIt));
			GetOwner()->GetGLObject()->DrawLine((*cpIt), (*(cpIt + 1)), glm::vec3(0.0f, 0.0f, 0.0f), 1.0f,
				glm::vec3(0.0f, 0.0f, 0.0f), false);
			cpIt = cpIt + 1;
		}
	}
	
	if (!msgSent)
	{
		if (controlPoints->size() > 1)
		{
			StartMovingAlongPath* moveAlongEvent =
				eventManager->GenerateEvent<StartMovingAlongPath>();
			moveAlongEvent->SetPath(spline);
			eventManager->BroadCastEvent(moveAlongEvent);
			msgSent = true;
			pathExists = true;
		}
	}
	

	/*double u = 0.23168;
	double my_s = spline->CurveDistanceAtU(u);
	double my_u = spline->UatCurveDistance(my_s);

	bool res = u == my_u;*/

	//double time = frameRateController->GetTime();


	//std::vector<glm::vec3> debug_curve_points =
	//	spline->GetArcLengthPoints();
	//
	//std::vector<glm::vec3>::iterator cpIt1 = debug_curve_points.begin();
	//if (debug_curve_points.size() == 0)
	//	return;

	//while (cpIt1 != debug_curve_points.end()-1)//debug_curve_points.begin() + 40)
	//{
	//	GetOwner()->GetGLObject()->DrawDot((*cpIt));
	//	GetOwner()->GetGLObject()->DrawLine((*cpIt1) + glm::vec3(1.0f, 0.0f, 1.0f), 
	//		(*(cpIt1 + 1)) + glm::vec3(1.0f, 0.0f, 1.0f), glm::vec3(0.0f, 1.0f, 1.0f), 20.0f, false);
	//	cpIt1 = cpIt1 + 1;
	//}

	////[0] = {x=2.04745102 y=0.000000000 z=7.11235332 ...}
	//glm::vec3 ptS = spline->GetPointPu(0.0000);
	//glm::vec3 pt1 = spline->GetPointPu(0.0001);
	//glm::vec3 pt2 = spline->GetPointPu(0.0002);
	//glm::vec3 pt3 = spline->GetPointPu(0.0003);
	//glm::vec3 pt4 = spline->GetPointPu(0.0004);
	//glm::vec3 ptF = spline->GetPointPu(0.0005);
	////[1] = {ui=1 point={x=2.05441165 y=0.200000003 z=7.09646940 ...} }
	return;

}


void SplinePathGeneratorComponent::HandleEvent(const Event* const evt)
{
	// TODO - Implement reactions to different events
	const CreateControlPoint* cpEvt = 
		dynamic_cast<const CreateControlPoint*>(evt);
	if (cpEvt)
	{
		GameObject* go = cpEvt->GetPoint();
		if (go->IsAlive)
		{
			cpGOs.push_back(cpEvt->GetPoint());
		}
		msgSent = false;
	}

	const DeleteControlPoints* cpDEvt =
		dynamic_cast<const DeleteControlPoints*>(evt);
	if (cpDEvt)
	{
		clearCpGOs(&cpGOs);
		spline->ResetTime();
	}

}

void SplinePathGeneratorComponent::Destroy()
{
	// TODO - Optional, use to release memory
	// This function is called by the user.
}


void SplinePathGeneratorComponent::eraseCurve()
{

	GetOwner()->GetGLObject()->ResetLineBuffers();
}



// utility functions:

void clearCpGOs(std::vector<GameObject*>* cpGos)
{
	for (size_t i = 0; i < cpGos->size(); i++)
	{
		(*cpGos)[i]->NeedsDeletion = true; // Need to implement memory management soon!!
		(*cpGos)[i]->IsAlive = false;
	}
	cpGos->clear();
}